#!/usr/bin/env python
#
# Tests for incremental drive-backup
#
# Copyright (C) 2015 John Snow for Red Hat, Inc.
#
# Based on 056.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import iotests


def io_write_patterns(img, patterns):
    for pattern in patterns:
        iotests.qemu_io('-c', 'write -P%s %s %s' % pattern, img)

class Bitmap:
    def __init__(self, name, drive):
        self.name = name
        self.drive = drive
        self.pattern = os.path.join(iotests.test_dir.replace('%', '%%'),
                                    '%s.%s.backup.%%i.img' % (drive['id'],
                                                              name))
        self.num = 0
        self.backups = list()

    def base_target(self):
        return self.drive['backup']

    def new_target(self, num=None):
        if num is None:
            num = self.num
        self.num = num + 1
        target = self.pattern % num
        self.backups.append(target)
        return target

    def last_target(self):
        if self.backups:
            return self.backups[-1]
        return self.base_target()

    def del_target(self):
        os.remove(self.backups.pop())
        self.num -= 1

    def __del__(self):
        for backup in self.backups:
            try:
                os.remove(backup)
            except OSError:
                pass

class TestIncrementalBackup(iotests.QMPTestCase):
    def setUp(self):
        self.bitmaps = list()
        self.files = list()
        self.drives = list()
        self.vm = iotests.VM()
        self.err_img = os.path.join(iotests.test_dir, 'err.%s' % iotests.imgfmt)

        # Create a base image with a distinctive patterning
        drive0 = self.add_node('drive0')
        self.img_create(drive0['file'], drive0['fmt'])
        self.vm.add_drive(drive0['file'])
        io_write_patterns(drive0['file'], (('0x41', 0, 512),
                                           ('0xd5', '1M', '32k'),
                                           ('0xdc', '32M', '124k')))
        self.vm.launch()


    def add_node(self, node_id, fmt=iotests.imgfmt, path=None, backup=None):
        if path is None:
            path = os.path.join(iotests.test_dir, '%s.%s' % (node_id, fmt))
        if backup is None:
            backup = os.path.join(iotests.test_dir,
                                  '%s.full.backup.%s' % (node_id, fmt))

        self.drives.append({
            'id': node_id,
            'file': path,
            'backup': backup,
            'fmt': fmt })
        return self.drives[-1]


    def img_create(self, img, fmt=iotests.imgfmt, size='64M',
                   parent=None, parentFormat=None):
        plist = list()
        if parent:
            if parentFormat is None:
                parentFormat = fmt
            iotests.qemu_img('create', '-f', fmt, img, size,
                             '-b', parent, '-F', parentFormat)
        else:
            iotests.qemu_img('create', '-f', fmt, img, size)
        self.files.append(img)


    def create_full_backup(self, drive=None):
        if drive is None:
            drive = self.drives[-1]

        res = self.vm.qmp('drive-backup', device=drive['id'],
                          sync='full', format=drive['fmt'],
                          target=drive['backup'])
        self.assert_qmp(res, 'return', {})
        self.wait_until_completed(drive['id'])
        self.check_full_backup(drive)
        self.files.append(drive['backup'])
        return drive['backup']


    def check_full_backup(self, drive=None):
        if drive is None:
            drive = self.drives[-1]
        self.assertTrue(iotests.compare_images(drive['file'], drive['backup']))


    def add_bitmap(self, name, drive):
        bitmap = Bitmap(name, drive)
        self.bitmaps.append(bitmap)
        result = self.vm.qmp('block-dirty-bitmap-add', node=drive['id'],
                             name=name)
        self.assert_qmp(result, 'return', {})
        return bitmap


    def create_incremental(self, bitmap=None, num=None,
                           parent=None, parentFormat=None, validate=True):
        if bitmap is None:
            bitmap = self.bitmaps[-1]

        if parent is None:
            parent = bitmap.last_target()

        target = bitmap.new_target(num)
        self.img_create(target, bitmap.drive['fmt'], parent=parent)

        result = self.vm.qmp('drive-backup', device=bitmap.drive['id'],
                             sync='dirty-bitmap', bitmap=bitmap.name,
                             format=bitmap.drive['fmt'], target=target,
                             mode='existing')
        self.assert_qmp(result, 'return', {})

        return self.wait_incremental(bitmap, validate)


    def wait_incremental(self, bitmap=None,
                         validate=True, error='Input/output error'):
        if bitmap is None:
            bitmap = self.bitmaps[-1]

        event = self.vm.event_wait(name="BLOCK_JOB_COMPLETED",
                                   match={'data': {'device':
                                                   bitmap.drive['id']}})
        if validate:
            self.assert_qmp_absent(event, 'data/error')
            return self.check_incremental(bitmap)
        else:
            self.assert_qmp(event, 'data/error', error)
            bitmap.del_target()
            return False


    def check_incremental(self, bitmap=None):
        if bitmap is None:
            bitmap = self.bitmaps[-1]
        self.assertTrue(iotests.compare_images(bitmap.drive['file'],
                                               bitmap.last_target()))
        return True


    def hmp_io_writes(self, drive, patterns):
        for pattern in patterns:
            self.vm.hmp_qemu_io(drive, 'write -P%s %s %s' % pattern)
        self.vm.hmp_qemu_io(drive, 'flush')


    def test_incremental_simple(self):
        '''
        Test: Create and verify three incremental backups.

        Create a bitmap and a full backup before VM execution begins,
        then create a series of three incremental backups "during execution,"
        i.e.; after IO requests begin modifying the drive.
        '''
        self.create_full_backup()
        self.add_bitmap('bitmap0', self.drives[0])

        # Sanity: Create a "hollow" incremental backup
        self.create_incremental()
        # Three writes: One complete overwrite, one new segment,
        # and one partial overlap.
        self.hmp_io_writes(self.drives[0]['id'], (('0xab', 0, 512),
                                                  ('0xfe', '16M', '256k'),
                                                  ('0x64', '32736k', '64k')))
        self.create_incremental()
        # Three more writes, one of each kind, like above
        self.hmp_io_writes(self.drives[0]['id'], (('0x9a', 0, 512),
                                                  ('0x55', '8M', '352k'),
                                                  ('0x78', '15872k', '1M')))
        self.create_incremental()
        return True


    def test_incremental_transaction(self):
        '''Test: Verify backups made from transactionally created bitmaps.

        Create a bitmap "before" VM execution begins, then create a second
        bitmap AFTER writes have already occurred. Use transactions to create
        a full backup and synchronize both bitmaps to this backup.
        Create an incremental backup through both bitmaps and verify that
        both backups match the current drive0 image.
        '''

        drive0 = self.drives[0]
        bitmap0 = self.add_bitmap('bitmap0', self.drives[0])
        self.hmp_io_writes(drive0['id'], (('0xab', 0, 512),
                                          ('0xfe', '16M', '256k'),
                                          ('0x64', '32736k', '64k')))
        bitmap1 = self.add_bitmap('bitmap1', drive0)

        result = self.vm.qmp('transaction', actions=[
            {
                'type': 'block-dirty-bitmap-clear',
                'data': { 'node': bitmap0.drive['id'],
                          'name': bitmap0.name },
            },
            {
                'type': 'block-dirty-bitmap-clear',
                'data': { 'node': bitmap1.drive['id'],
                          'name': bitmap1.name },
            },
            {
                'type': 'drive-backup',
                'data': { 'device': drive0['id'],
                          'sync': 'full',
                          'format': drive0['fmt'],
                          'target': drive0['backup'] },
            }
        ])
        self.assert_qmp(result, 'return', {})
        self.wait_until_completed()
        self.files.append(drive0['backup'])
        self.check_full_backup()

        self.hmp_io_writes(drive0['id'], (('0x9a', 0, 512),
                                          ('0x55', '8M', '352k'),
                                          ('0x78', '15872k', '1M')))
        # Both bitmaps should be in sync and create fully valid
        # incremental backups
        res1 = self.create_incremental(bitmap0)
        res2 = self.create_incremental(bitmap1)
        self.assertTrue(res1 and res2)


    def test_incremental_failure(self):
        '''Test: Verify backups made after a failure are correct.

        Simulate a failure during an incremental backup block job,
        emulate additional writes, then create another incremental backup
        afterwards and verify that the backup created is correct.
        '''

        # Create a blkdebug interface to this img as 'drive1',
        # but don't actually create a new image.
        drive1 = self.add_node('drive1', self.drives[0]['fmt'],
                               path=self.drives[0]['file'],
                               backup=self.drives[0]['backup'])
        result = self.vm.qmp('blockdev-add', options={
            'id': 'drive1',
            'driver': drive1['fmt'],
            'file': {
                'driver': 'blkdebug',
                'image': {
                    'driver': 'file',
                    'filename': drive1['file']
                },
                'set-state': [{
                    'event': 'flush_to_disk',
                    'state': 1,
                    'new_state': 2
                }],
                'inject-error': [{
                    'event': 'read_aio',
                    'errno': 5,
                    'state': 2,
                    'immediately': False,
                    'once': True
                }],
            }
        })
        self.assert_qmp(result, 'return', {})

        self.create_full_backup(self.drives[0])
        self.add_bitmap('bitmap0', drive1)
        # Note: at this point, during a normal execution,
        # Assume that the VM resumes and begins issuing IO requests here.

        self.hmp_io_writes(drive1['id'], (('0xab', 0, 512),
                                          ('0xfe', '16M', '256k'),
                                          ('0x64', '32736k', '64k')))

        result = self.create_incremental(validate=False)
        self.assertFalse(result)
        self.hmp_io_writes(drive1['id'], (('0x9a', 0, 512),
                                          ('0x55', '8M', '352k'),
                                          ('0x78', '15872k', '1M')))
        self.create_incremental()


    def test_sync_dirty_bitmap_missing(self):
        self.assert_no_active_block_jobs()
        self.files.append(self.err_img)
        result = self.vm.qmp('drive-backup', device=self.drives[0]['id'],
                             sync='dirty-bitmap', format=self.drives[0]['fmt'],
                             target=self.err_img)
        self.assert_qmp(result, 'error/class', 'GenericError')


    def test_sync_dirty_bitmap_not_found(self):
        self.assert_no_active_block_jobs()
        self.files.append(self.err_img)
        result = self.vm.qmp('drive-backup', device=self.drives[0]['id'],
                             sync='dirty-bitmap', bitmap='unknown',
                             format=self.drives[0]['fmt'], target=self.err_img)
        self.assert_qmp(result, 'error/class', 'GenericError')


    def tearDown(self):
        self.vm.shutdown()
        for filename in self.files:
            try:
                os.remove(filename)
            except OSError:
                pass


if __name__ == '__main__':
    iotests.main(supported_fmts=['qcow2'])
