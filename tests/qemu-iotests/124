#!/usr/bin/env python
#
# Tests for incremental drive-backup
#
# Copyright (C) 2015 John Snow for Red Hat, Inc.
#
# Based on 056.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import iotests


def io_write_patterns(img, patterns):
    for pattern in patterns:
        iotests.qemu_io('-c', 'write -P%s %s %s' % pattern, img)

class Bitmap:
    def __init__(self, name, node):
        self.name = name
        self.node = node
        self.pattern = os.path.join(iotests.test_dir.replace('%', '%%'),
                                    '%s.backup.%%i.img' % name)
        self.num = 0
        self.backups = list()

    def new_target(self, num=None):
        if num is None:
            num = self.num
        self.num = num + 1
        target = self.pattern % num
        self.backups.append(target)
        return target

    def last_target(self):
        return self.backups[-1]

    def del_target(self):
        os.remove(self.backups.pop())
        self.num -= 1

    def __del__(self):
        for backup in self.backups:
            try:
                os.remove(backup)
            except OSError:
                pass

class TestIncrementalBackup(iotests.QMPTestCase):
    def setUp(self):
        self.bitmaps = list()
        self.files = list()
        self.vm = iotests.VM()
        self.test_img = os.path.join(iotests.test_dir, 'base.img')
        self.full_bak = os.path.join(iotests.test_dir, 'backup.img')
        self.foo_img = os.path.join(iotests.test_dir, 'foo.bar')
        self.img_create(self.test_img, iotests.imgfmt)
        self.vm.add_drive(self.test_img)
        # Create a base image with a distinctive patterning
        io_write_patterns(self.test_img, (('0x41', 0, 512),
                                          ('0xd5', '1M', '32k'),
                                          ('0xdc', '32M', '124k')))
        self.vm.launch()


    def img_create(self, img, fmt=iotests.imgfmt, size='64M',
                   parent=None, parentFormat=None):
        plist = list()
        if parent:
            if parentFormat is None:
                parentFormat = fmt
            iotests.qemu_img('create', '-f', fmt, img, size,
                             '-b', parent, '-F', parentFormat)
        else:
            iotests.qemu_img('create', '-f', fmt, img, size)
        self.files.append(img)


    def create_full_backup(self, drive='drive0'):
        res = self.vm.qmp('drive-backup', device=drive,
                          sync='full', format=iotests.imgfmt,
                          target=self.full_bak)
        self.assert_qmp(res, 'return', {})
        self.wait_until_completed(drive)
        self.check_full_backup()
        self.files.append(self.full_bak)


    def check_full_backup(self):
        self.assertTrue(iotests.compare_images(self.test_img, self.full_bak))


    def add_bitmap(self, name, node='drive0'):
        bitmap = Bitmap(name, node)
        self.bitmaps.append(bitmap)
        result = self.vm.qmp('block-dirty-bitmap-add', node=bitmap.node,
                             name=bitmap.name)
        self.assert_qmp(result, 'return', {})
        return bitmap


    def create_incremental(self, bitmap=None, num=None,
                           parent=None, parentFormat=None, validate=True):
        if bitmap is None:
            bitmap = self.bitmaps[-1]

        # If this is the first incremental backup for a bitmap,
        # use the full backup as a backing image. Otherwise, use
        # the last incremental backup.
        if parent is None:
            if bitmap.num == 0:
                parent = self.full_bak
            else:
                parent = bitmap.last_target()

        target = bitmap.new_target(num)
        self.img_create(target, iotests.imgfmt, parent=parent)

        result = self.vm.qmp('drive-backup', device=bitmap.node,
                             sync='dirty-bitmap', bitmap=bitmap.name,
                             format=iotests.imgfmt, target=target,
                             mode='existing')
        self.assert_qmp(result, 'return', {})

        event = self.wait_until_completed(bitmap.node, check_offset=validate,
                                          allow_failures=(not validate))
        if 'error' in event['data']:
            bitmap.del_target()
            return False
        if validate:
            return self.check_incremental(target)


    def check_incremental(self, target=None):
        if target is None:
            target = self.bitmaps[-1].last_target()
        self.assertTrue(iotests.compare_images(self.test_img, target))
        return True


    def hmp_io_writes(self, drive, patterns):
        for pattern in patterns:
            self.vm.hmp_qemu_io(drive, 'write -P%s %s %s' % pattern)
        self.vm.hmp_qemu_io(drive, 'flush')


    def test_incremental_simple(self):
        '''
        Test: Create and verify three incremental backups.

        Create a bitmap and a full backup before VM execution begins,
        then create a series of three incremental backups "during execution,"
        i.e.; after IO requests begin modifying the drive.
        '''
        self.create_full_backup()
        self.add_bitmap('bitmap0', 'drive0')

        # Sanity: Create a "hollow" incremental backup
        self.create_incremental()
        # Three writes: One complete overwrite, one new segment,
        # and one partial overlap.
        self.hmp_io_writes('drive0', (('0xab', 0, 512),
                                      ('0xfe', '16M', '256k'),
                                      ('0x64', '32736k', '64k')))
        self.create_incremental()
        # Three more writes, one of each kind, like above
        self.hmp_io_writes('drive0', (('0x9a', 0, 512),
                                      ('0x55', '8M', '352k'),
                                      ('0x78', '15872k', '1M')))
        self.create_incremental()
        return True


    def test_incremental_transaction(self):
        '''Test: Verify backups made from transactionally created bitmaps.

        Create a bitmap "before" VM execution begins, then create a second
        bitmap AFTER writes have already occurred. Use transactions to create
        a full backup and synchronize both bitmaps to this backup.
        Create an incremental backup through both bitmaps and verify that
        both backups match the full backup.
        '''
        bitmap0 = self.add_bitmap('bitmap0', 'drive0')
        self.hmp_io_writes('drive0', (('0xab', 0, 512),
                                      ('0xfe', '16M', '256k'),
                                      ('0x64', '32736k', '64k')))
        bitmap1 = self.add_bitmap('bitmap1', 'drive0')

        result = self.vm.qmp('transaction', actions=[
            {
                'type': 'block-dirty-bitmap-clear',
                'data': { 'node': 'drive0',
                          'name': 'bitmap0' },
            },
            {
                'type': 'block-dirty-bitmap-clear',
                'data': { 'node': 'drive0',
                          'name': 'bitmap1' },
            },
            {
                'type': 'drive-backup',
                'data': { 'device': 'drive0',
                          'sync': 'full',
                          'format': iotests.imgfmt,
                          'target': self.full_bak },
            }
        ])
        self.assert_qmp(result, 'return', {})
        self.wait_until_completed()
        self.files.append(self.full_bak)
        self.check_full_backup()

        self.hmp_io_writes('drive0', (('0x9a', 0, 512),
                                      ('0x55', '8M', '352k'),
                                      ('0x78', '15872k', '1M')))
        # Both bitmaps should be in sync and create fully valid
        # incremental backups
        res1 = self.create_incremental(bitmap0)
        res2 = self.create_incremental(bitmap1)
        self.assertTrue(res1 and res2)


    def test_incremental_failure(self):
        '''Test: Verify backups made after a failure are correct.

        Simulate a failure during an incremental backup block job,
        emulate additional writes, then create another incremental backup
        afterwards and verify that the backup created is correct.
        '''

        # Create a blkdebug interface to this img as 'drive1'
        result = self.vm.qmp('blockdev-add', options={
            'id': 'drive1',
            'driver': iotests.imgfmt,
            'file': {
                'driver': 'blkdebug',
                'image': {
                    'driver': 'file',
                    'filename': self.test_img
                },
                'set-state': [{
                    'event': 'flush_to_disk',
                    'state': 1,
                    'new_state': 2
                }],
                'inject-error': [{
                    'event': 'read_aio',
                    'errno': 5,
                    'state': 2,
                    'immediately': False,
                    'once': True
                }],
            }
        })
        self.assert_qmp(result, 'return', {})

        self.create_full_backup()
        self.add_bitmap('bitmap0', 'drive1')
        # Note: at this point, during a normal execution,
        # Assume that the VM resumes and begins issuing IO requests here.

        self.hmp_io_writes('drive1', (('0xab', 0, 512),
                                      ('0xfe', '16M', '256k'),
                                      ('0x64', '32736k', '64k')))

        result = self.create_incremental(validate=False)
        self.assertFalse(result)
        self.hmp_io_writes('drive1', (('0x9a', 0, 512),
                                      ('0x55', '8M', '352k'),
                                      ('0x78', '15872k', '1M')))
        self.create_incremental()


    def test_sync_dirty_bitmap_missing(self):
        self.assert_no_active_block_jobs()
        self.files.append(self.foo_img)
        result = self.vm.qmp('drive-backup', device='drive0',
                             sync='dirty-bitmap', format=iotests.imgfmt,
                             target=self.foo_img)
        self.assert_qmp(result, 'error/class', 'GenericError')


    def test_sync_dirty_bitmap_not_found(self):
        self.assert_no_active_block_jobs()
        self.files.append(self.foo_img)
        result = self.vm.qmp('drive-backup', device='drive0',
                             sync='dirty-bitmap', bitmap='unknown',
                             format=iotests.imgfmt, target=self.foo_img)
        self.assert_qmp(result, 'error/class', 'GenericError')


    def tearDown(self):
        self.vm.shutdown()
        for filename in self.files:
            try:
                os.remove(filename)
            except OSError:
                pass


if __name__ == '__main__':
    iotests.main(supported_fmts=['qcow2'])
